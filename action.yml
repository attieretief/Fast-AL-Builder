name: 'Fast AL Builder'
description: 'Ultra-fast Business Central AL extension builder with optimized multi-runner pipeline, code signing, and AppSource publishing'
author: 'Attie Retief'

branding:
  icon: 'zap'
  color: 'purple'

inputs:
  # Required Secrets (configure in repository settings)
  # - LINC_TOKEN: LINC authentication token for symbol download
  # - AZ_KEY_VAULT_URI: Azure Key Vault URI hosting the certificate (optional)
  # - AZ_KEY_VAULT_CERTIFICATE_NAME: Certificate name inside the vault (optional)
  # - AZ_KEY_VAULT_APPLICATION_ID: Azure AD application ID for Key Vault access (optional)
  # - AZ_KEY_VAULT_APPLICATION_SECRET: Azure AD application secret (optional)
  # - AZ_KEY_VAULT_TENANT_ID: Azure AD tenant ID (optional)
  # - AZ_SIGN_TIMESTAMP_URL: Custom timestamp server URL (optional)
  # - AZURE_CLIENT_ID: Azure service principal client ID (for publishing)
  # - AZURE_CLIENT_SECRET: Azure service principal secret (for publishing)
  # - AZURE_TENANT_ID: Azure tenant ID (for publishing)
  
  # Build Configuration
  build-mode:
    description: 'Build mode: test or build'
    required: false
    default: 'build'
  
  # Skip Options
  skip-symbols:
    description: 'Skip symbol download step'
    required: false
    default: 'false'
    
  skip-signing:
    description: 'Skip code signing step'
    required: false
    default: 'false'
    
  skip-publishing:
    description: 'Skip AppSource publishing step'
    required: false
    default: 'false'
  
  # Publishing Configuration
  publish-mode:
    description: 'Publishing mode: draft, submit, or auto-promote'
    required: false
    default: 'draft'
  
  # Timeout
  timeout-minutes:
    description: 'Maximum time to wait for pipeline completion (in minutes)'
    required: false
    default: '60'
  
  # Advanced Configuration
  workflow-file:
    description: 'Custom workflow file name (advanced users only)'
    required: false
    default: 'al-extension-pipeline.yml'

outputs:
  app-file:
    description: 'Name of the built .app file'
    value: ${{ steps.get-results.outputs.app-file }}
  
  app-version:
    description: 'Version number of the built extension'
    value: ${{ steps.get-results.outputs.app-version }}
  
  build-success:
    description: 'Whether the build was successful'
    value: ${{ steps.get-results.outputs.build-success }}
  
  signing-success:
    description: 'Whether code signing was successful'
    value: ${{ steps.get-results.outputs.signing-success }}
  
  publishing-success:
    description: 'Whether publishing was successful'
    value: ${{ steps.get-results.outputs.publishing-success }}
  
  overall-success:
    description: 'Whether the entire pipeline was successful'
    value: ${{ steps.get-results.outputs.overall-success }}

runs:
  using: 'composite'
  steps:
    - name: Generate Workflow ID
      id: generate-id
      shell: bash
      run: |
        # Create unique workflow identifier
        WORKFLOW_ID="al-$(date +%s)-$(printf '%04d' $RANDOM)"
        echo "workflow-id=$WORKFLOW_ID" >> $GITHUB_OUTPUT
        echo "üÜî Generated workflow ID: $WORKFLOW_ID"
    
    - name: Trigger Multi-Runner Pipeline
      shell: bash
      run: |
        echo "üöÄ Triggering AL Extension Pipeline with multi-runner support..."
        
        # Trigger the internal workflow
        curl -L \
          -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ github.token }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/repos/${{ github.repository }}/actions/workflows/al-extension-pipeline.yml/dispatches" \
          -d "{
            \"ref\": \"${{ github.ref }}\",
            \"inputs\": {
              \"workflow-id\": \"${{ steps.generate-id.outputs.workflow-id }}\",
              \"build-mode\": \"${{ inputs.build-mode }}\",
              \"skip-signing\": \"${{ inputs.skip-signing }}\",
              \"skip-publishing\": \"${{ inputs.skip-publishing }}\",
              \"publish-mode\": \"${{ inputs.publish-mode }}\",
              \"source-repo\": \"${{ github.repository }}\",
              \"source-sha\": \"${{ github.sha }}\",
              \"source-ref\": \"${{ github.ref }}\"
            }
          }"
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Pipeline triggered successfully"
        else
          echo "‚ùå Failed to trigger pipeline"
          exit 1
        fi
    
    - name: Wait for Pipeline Completion
      shell: bash
      run: |
        echo "‚è≥ Waiting for AL Extension Pipeline to complete..."
        echo "   Workflow ID: ${{ steps.generate-id.outputs.workflow-id }}"
        echo "   Maximum wait time: ${{ inputs.timeout-minutes }} minutes"
        
        # Use Python for reliable API polling
        python3 << 'EOF'
        import os
        import time
        import json
        import sys
        from urllib.request import Request, urlopen
        from urllib.parse import quote
        
        # Configuration
        workflow_id = os.environ['WORKFLOW_ID']
        repo = os.environ['GITHUB_REPOSITORY'] 
        token = os.environ['GITHUB_TOKEN']
        timeout_minutes = int(os.environ.get('TIMEOUT_MINUTES', '60'))
        
        headers = {
            'Accept': 'application/vnd.github+json',
            'Authorization': f'Bearer {token}',
            'X-GitHub-Api-Version': '2022-11-28'
        }
        
        # Convert timeout to seconds
        max_wait = timeout_minutes * 60
        poll_interval = 30  # Check every 30 seconds
        start_time = time.time()
        
        print(f"Monitoring workflow: {workflow_id}")
        print(f"Repository: {repo}")
        print(f"Timeout: {timeout_minutes} minutes")
        print("=" * 50)
        
        last_status = None
        
        while time.time() - start_time < max_wait:
            try:
                # Get recent workflow runs
                url = f"https://api.github.com/repos/{repo}/actions/runs?per_page=20"
                req = Request(url, headers=headers)
                
                with urlopen(req) as response:
                    data = json.loads(response.read().decode())
                
                # Find our workflow run by name pattern
                target_run = None
                for run in data.get('workflow_runs', []):
                    run_name = run.get('name', '')
                    # Look for our workflow ID in the run name or check if it matches our dispatch
                    if (workflow_id in run_name or 
                        run.get('workflow_id') and 
                        abs(time.time() - time.mktime(time.strptime(run['created_at'], '%Y-%m-%dT%H:%M:%SZ'))) < 300):
                        target_run = run
                        break
                
                if target_run:
                    status = target_run['status']
                    conclusion = target_run.get('conclusion')
                    run_url = target_run['html_url']
                    
                    # Only print status updates when they change
                    current_status = f"{status}:{conclusion}"
                    if current_status != last_status:
                        elapsed = int(time.time() - start_time)
                        print(f"[{elapsed:03d}s] Status: {status}" + (f", Conclusion: {conclusion}" if conclusion else ""))
                        print(f"       Run URL: {run_url}")
                        last_status = current_status
                    
                    if status == 'completed':
                        if conclusion == 'success':
                            print("\n‚úÖ Pipeline completed successfully!")
                            sys.exit(0)
                        elif conclusion == 'cancelled':
                            print("\n‚ö†Ô∏è Pipeline was cancelled")
                            sys.exit(1)
                        else:
                            print(f"\n‚ùå Pipeline failed with conclusion: {conclusion}")
                            print(f"   Check the workflow run for details: {run_url}")
                            sys.exit(1)
                else:
                    elapsed = int(time.time() - start_time)
                    print(f"[{elapsed:03d}s] Waiting for workflow to appear...")
                
                time.sleep(poll_interval)
                
            except Exception as e:
                print(f"Error checking pipeline status: {e}")
                time.sleep(poll_interval)
        
        print(f"\n‚ùå Pipeline timed out after {timeout_minutes} minutes")
        sys.exit(1)
        EOF
      env:
        WORKFLOW_ID: ${{ steps.generate-id.outputs.workflow-id }}
        GITHUB_TOKEN: ${{ github.token }}
        TIMEOUT_MINUTES: ${{ inputs.timeout-minutes }}
    
    - name: Download Pipeline Results
      uses: actions/download-artifact@v4
      with:
        name: pipeline-results-${{ steps.generate-id.outputs.workflow-id }}
        path: pipeline-results/
    
    - name: Extract Results
      id: get-results
      shell: bash
      run: |
        echo "üìä Extracting pipeline results..."
        
        if [ -f "pipeline-results/summary.json" ]; then
          # Parse JSON results
          APP_FILE=$(jq -r '.app_file // "unknown"' pipeline-results/summary.json)
          APP_VERSION=$(jq -r '.app_version // "unknown"' pipeline-results/summary.json)
          BUILD_SUCCESS=$(jq -r '.build_success // "false"' pipeline-results/summary.json)
          SIGNING_SUCCESS=$(jq -r '.signing_success // "false"' pipeline-results/summary.json)
          PUBLISHING_SUCCESS=$(jq -r '.publishing_success // "false"' pipeline-results/summary.json)
          OVERALL_SUCCESS=$(jq -r '.overall_success // "false"' pipeline-results/summary.json)
          
          # Set outputs
          echo "app-file=$APP_FILE" >> $GITHUB_OUTPUT
          echo "app-version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "build-success=$BUILD_SUCCESS" >> $GITHUB_OUTPUT
          echo "signing-success=$SIGNING_SUCCESS" >> $GITHUB_OUTPUT
          echo "publishing-success=$PUBLISHING_SUCCESS" >> $GITHUB_OUTPUT
          echo "overall-success=$OVERALL_SUCCESS" >> $GITHUB_OUTPUT
          
          # Display summary
          echo "‚úÖ Results extracted successfully:"
          echo "   üì¶ App File: $APP_FILE"
          echo "   üè∑Ô∏è  Version: $APP_VERSION"
          echo "   üî® Build: $BUILD_SUCCESS"
          echo "   üñäÔ∏è  Signing: $SIGNING_SUCCESS"
          echo "   üì§ Publishing: $PUBLISHING_SUCCESS"
          echo "   üéØ Overall: $OVERALL_SUCCESS"
        else
          echo "‚ùå Pipeline results not found"
          echo "app-file=unknown" >> $GITHUB_OUTPUT
          echo "app-version=unknown" >> $GITHUB_OUTPUT
          echo "build-success=false" >> $GITHUB_OUTPUT
          echo "signing-success=false" >> $GITHUB_OUTPUT
          echo "publishing-success=false" >> $GITHUB_OUTPUT
          echo "overall-success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Cleanup Temporary Artifacts
      if: always()
      shell: bash
      run: |
        echo "üßπ Cleaning up temporary artifacts..."
        # Note: Artifacts will auto-expire after 1 day, but we could delete them here if needed
        echo "   Temporary artifacts will be automatically cleaned up"